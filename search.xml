<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>序</title>
    <url>/posts/2021/03334513da/</url>
    <content><![CDATA[<h4 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h4><p>我到现在都还记得当年高考填报志愿的时候，面对一堆陌生的专业，一开始不知道怎么选择，后来回忆起电影《<a href="https://movie.douban.com/subject/1432146/">钢铁侠</a>》里 J.A.R.V.I.S. 出现的片段，真的很酷，当时就想要是我也能搞出来这么个东西，那就太方便了，于是带着期望选择了软件工程专业。到了学校，开始上课，对计算机有了更多的了解，才意识到，我目前学的东西还是太基础，离自己打造人工智能的管家还比较遥远。不过到现在来看，已经有越来越多的AI应用落地了，也确实在一定程度上给人们的生活带来了便利。就这样，我进入了计算机行业，然后开始接触编程和程序设计，看着自己写的程序能跑起来，能处理一些简单的任务，再到接触一些大的项目，有团队合作，任务分工，参与到大的项目中完善和维护系统，自己对于系统开发设计也有了更深刻的认识。</p>
<span id="more"></span>

<p>目前我已经结束了一段接近3年的工作，工作中遇到过不少问题，也解决了不少问题，不过缺少对问题的总结记录和整理，虽说下次遇到同样的问题能够更快的解决，但是时间久了处理起来也还是会生疏。及时记录问题，贡献解决方案对个人和行业来说都是非常有益的事情，所以这一次，我选择了搭建个人博客来做这件事情，到现在博客基本搭建完成，我可以专注于内容本身了。前前后后花了快1个月的时间，做了各种尝试和取舍，把自己喜欢和觉得有意思的元素都融合到了一起，从0到1的这个过程，还挺满意和享受的，之后也会出几篇博客搭建的内容。</p>
<h4 id="学习探索"><a href="#学习探索" class="headerlink" title="学习探索"></a>学习探索</h4><p>对于计算机行业来说，技术发展和变化节奏都比较快，所以对于从业人员的学习能力有比较高的要求，我在学习上做过一些探索和研究，有一些小小的心得体会，愿意和大家分享，也欢迎大家和我分享交流自己的学习心得。</p>
<h5 id="主动学习"><a href="#主动学习" class="headerlink" title="主动学习"></a>主动学习</h5><p><a href="https://baike.baidu.com/item/%E5%AD%A6%E4%B9%A0%E9%87%91%E5%AD%97%E5%A1%94">学习金字塔</a>以学习内容平均留存率为衡量指标，比对了主动学习和被动学习的学习效果，整体上来说，主动学习的效果更好，知识留存率更高。主动学习分为三种类型：讨论、实践、教会别人，这三种类型的学习效果依次增加。所以我们在自己的学习过程中，可以适当的应用这三种方式来提高学习效果，比如和同事朋友一起交流讨论一个问题，自己把一些示例代码敲一敲，调试一下，运行一下，修改运行一下，看看结果是不是符合自己的预期，当然也可以把一些好的开源项目克隆到本地运行调试一下，这个过程就能学到不少东西。主动学习的最高境界就是自己当老师，把自己学到的东西分享给周围的人，把内容讲清楚，讲明白，写博客就是一种非常不错的方式，不仅能记录下自己的思考和想法，还能把一些有价值的好玩儿的想法分享出去，这个过程就能加深你对知识本身的理解和应用。</p>
<h5 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h5><p>10000小时天才定律 VS 刻意练习？想要知道这个问题的答案可以看两本书《<a href="https://book.douban.com/subject/25863621/">异类</a>》、《<a href="https://book.douban.com/subject/26895993/">刻意练习</a>》，刻意练习概括来说就是有目的的练习，寻求反馈，通过反馈找出自己的不足，改善工作流程，调整练习内容，总结有效方法，从而提高技能水平。反馈+调整是很重要的，如果只是简单重复的话，就算是10000个小时，也很难达到大师的水平。刻意练习最直观的例子就是弹钢琴，既需要保证练习的时长，还需要得到老师的指导反馈才能有所突破。所以为了更近一步体会刻意练习的感觉，我自己也在练琴，因为平时的工作就是敲键盘，通过职业的训练手速还可以，感觉练琴和敲键盘其实很相似，所以就入坑了，这里推荐一个入坑视频《<a href="https://www.bilibili.com/video/BV1hD4y1D7AB">处处吻</a>》。另外专栏《<a href="https://time.geekbang.org/column/intro/100002201">左耳听风</a>》的《<a href="https://time.geekbang.org/column/article/14360">98 | 高效学习：深度，归纳和坚持实践</a>》这一篇文章中作者提出了ARTS的活动，就是每人每周写一个 ARTS：Algorithm 是一道算法题，Review 是读一篇英文文章，Technique/Tips 是分享一个小技术，Share 是分享一个观点。我之前并没有参加，现在博客搭好了，想来尝试一下，我把具体的任务活动放到了<a href="https://trello.com/b/j3b08arS/arts">Trello</a>上，这样大家就能看到我的任务进度以及分享的内容了。</p>
<h5 id="费曼技巧"><a href="#费曼技巧" class="headerlink" title="费曼技巧"></a>费曼技巧</h5><p><a href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E8%B2%BB%E6%9B%BC">理查德·费曼</a>是一位获得诺贝尔奖的美国物理学家，<a href="https://wiki.mbalib.com/wiki/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95">费曼学习法</a>就是由他提出的。使用这个方法可以让我们更好的理解自己学习的东西，其中衡量标准就是，你能不能把自己学习的东西，让一位8岁的小朋友理解，这就需要我们用小朋友能够理解的语言去解释我们学习的概念或者是理论，这背后通常需要自己对一个概念把握准确，理解清晰，同时能和周围具体的事物发生联系。通过这种方式，我能把学到的有用的东西，和家人朋友讲明白，尤其是不同行业的人交流的时候，大家对彼此的行业都不太清楚，借助费曼技巧把一些行业相关的东西讲的通俗易懂，这样大家的沟通就能更顺畅。费曼是一个非常有趣的人，在《<a href="https://book.douban.com/subject/1391772/">别逗了，费曼先生!</a>》中记录了他做过的有意思的事情，观察蚂蚁、打鼓、撬开秘密基地的各个保险柜等等，想要知道更多精彩的故事，可以找书来读一读。</p>
<h5 id="学习闭环"><a href="#学习闭环" class="headerlink" title="学习闭环"></a>学习闭环</h5><p>输入-&gt;笔记-&gt;内化-&gt;实践-&gt;输出</p>
<p>学习可以分为多个环节，但是大多数时候我们学习都停留在输入和笔记环节，如果没有考试和面试的话，我们也不知道啥时候会再翻开笔记，随着时间的流逝，之前学过的东西就会开始遗忘，如果是用纸质笔记本来记录的话，很有可能已经连笔记都找不到了。所以怎样更好的管理自己的笔记，能在需要的时候随时找到就很重要，关于<a href="https://www.candobear.com/detail/p_5a25032fec88a_fZkzfMV8/6">知识管理</a>和<a href="https://www.candobear.com/detail/p_5933cbe7d76ef_St5XrFGk/6">知识内化</a>，我学习了这两个课程之后有了更近一步的理解和认识，感兴趣的话可以尝试一下。走完内化环节，应该就对知识本身掌握的差不多了，但是这还不够，毕竟理论和实践还是有一段距离要走的，实践是检验真理的唯一标准。实践完知道怎么用了，可以更近一步，把实践的经历和心得记录分享出来，记录其实是分享的第一步，是分享给自己，真正的分享就是把自己学到的东西分享给周围的人，或者分享到公开的平台上。这样就走完了一个学习的闭环，输出还是很重要的，自己理解是一回事儿，能给别人讲明白是另一回事儿，强化输出可以让知识沉淀也能很好的锻炼我们语言组织和表达的能力。</p>
<h5 id="思维闭环"><a href="#思维闭环" class="headerlink" title="思维闭环"></a>思维闭环</h5><p>想法-&gt;记录(提问)-&gt;思考-&gt;探索(求解)-&gt;实践-&gt;总结-&gt;分享(潜藏)-&gt;完善-&gt;关联-&gt;更新-&gt;归档</p>
<p>我平时有记录问题想法的习惯，这个思维闭环也不是我一开始就知道的，之前仅停留在探索的环节，就是有了问题，记录下来之后，闲暇的时候会去尝试找到问题的答案，是一个求解的过程，偶然的几次，当我找到问题答案的时候，我会忍不住和朋友分享，这个过程重复出现过好几次。于是我开始意识到，这个地方应该是有一个闭环的，所以我开始尝试完善和补充这里面的中间环节，最让我感到有意思的是，在和朋友分享的过程中，因为交流是随机的，偶尔会出现灵感的碰撞，聊着聊着，就会有一些新的想法冒出来，很神奇，这些想法其实已经早就存在了，但是我之前没有注意到，我把这类想法称之为潜在的想法。所以你看分享不光是能传递价值，而且可以激发出来新的想法和思考，也让我有更多尝试的方向。发现了这些新想法我会及时的去把它们记录下来，和之前的一些想法尝试关联，然后更新旧的一些想法，最后归档。这个过程偶尔会给我带来一些新的思考和启发，觉得挺有意思的，而且我也意识到，这个思维闭环的流程打通之后，你引入的想法越多，你的收获也会越多。</p>
<h5 id="学习体验"><a href="#学习体验" class="headerlink" title="学习体验"></a>学习体验</h5><p>体验简单划分为好的体验和不好的体验，对于好的体验，我们会不自觉的想多经历几次，对于差的体验，我们会直接拒绝。用生活中的例子来说明，比如到一个餐馆用餐，如果这个餐馆的卫生条件不行，服务态度不行，价格不公道，菜也不符合自己的口味，那我们大概率是不会再去第二次的。在产品设计中，用户体验也是非常重要的一个指标，产品、设计、交互、工程师会不断优化和改善用户体验，让产品更符合用户的使用习惯，这样才能留住老用户，吸引新用户。对于学习来说也是同样的道理，如果学习体验太差，比如一来就从最困难的题目开始，半天都没有思路，不知道怎么开始，那这就是一种不好的体验，很可能就会直接放弃掉，然后去玩儿手机了，相反，如果有一个从易到难的过程，能从自己熟悉题目开始解题，而且题目越做越顺手，那这种体验就非常棒，我们就更容易完成题目。对于阅读也同样适用，环境，氛围，情绪，内容，情节，这些虽说不是阅读过程中最主要的影响因素，但是有意识的去把这些因素往积极的方向推进，这种体验和效率的差别就像是在工地旁看书、在咖啡馆看书、在家看书和在图书馆看书的差别。对于想要作为习惯来培养的事情，可以通过不断优化体验来让这件事情做起来更舒服，更顺畅，这样就更容易持续下去。反过来，对于想要做出改变的事情，比如想要放下手机，从体验的角度分析，刷手机停不下来，主要就是网络太顺畅，内容太有意思，手机性能过于强悍，应用种类过于丰富，运行过于流畅，使用过于频繁，与之相对应的解决方案包括降低网速，卸载应用，降低配置，限制时间，更换非智能手机，体验变差了，自然我们就能放得下手机了。我自己的例子是，在平板上刷视频体验非常好，不容易停下来，后来把应用卸载了，看视频只通过网页浏览，同时把视频的画质调低，果然刷视频的频率显著降低。</p>
<h5 id="流程搭建"><a href="#流程搭建" class="headerlink" title="流程搭建"></a>流程搭建</h5><p>流程化和自动化是开发过程中少不了的一部分，但这更多的是在工作中，那生活中能不能同样的打造和搭建自己的流程呢，比如阅读和写作？可以对任务进行分解，写作包括选题、找材料、阅读材料、提取观点、比对观点，整理总结等等，不过我这里想分享的不是这些具体的流程要怎么去做，而是说在开始做一件事情的时候，如果什么都没有，搭建流程费时费力为什么还要去做？就拿我搭个人博客这件事情来说，为什么不直接在其他的博客平台直接创作呢，这样还能把文章同时发布到多个平台。这个对于普通人来说确实是这样，但是对于开发人员来说，就少了自己动手的乐趣，从0到1的过程还是很不错的，在这个过程中会有很多的问题等着解决，好在我并不是第一个做这件事情的人，已经有无数的前人把自己遇到的问题和解决方案分享了出来，顺着他们的指引我也完成了自己博客的搭建。这个搭建博客的过程其实和挖掘隧道很类似，在没有隧道之前，为了通过一个地方，可能得绕很远的路，会有更高的时间和人力成本，从短期来看，挖通隧道会花费很多的人力物力财力，但是从长期来看，这又是一个一劳永逸的事情，只要把隧道打通，把流程打通，从长期来看会节省更多的时间成本，这个事情是有长远价值的。所以对于这种一劳永逸的事情我也是愿意去做的，而且遇到问题解决问题感觉还挺不错的，会有不一样的收获，现在我就可以更多的专注在内容上了。</p>
<h5 id="极其幸运"><a href="#极其幸运" class="headerlink" title="极其幸运"></a>极其幸运</h5><p>阅人无数：视频平台的兴起，让无数的普通人也能够分享自己的生活，能让更多人看到和自己不一样的生活方式，我觉得这样的挺好的，毕竟人不可能只有一种活法，每个人都有自己独特的经历。我所接触的平台有两个<a href="https://www.youtube.com/">油管</a>和<a href="https://www.bilibili.com/">B站</a>，众所周知B站是个学习的平台，这两个平台也让无数的人脱颖而出，成为百万粉丝的博主，也有更多的博主在走向百万粉的路上，至于怎么使用这两个平台，不同的人有不同的使用方式，也没有统一的标准和绝对的对错之分，只要自己用的开心就好。我自己是把平台作为窗口，让我可以看到更多的人，向这些人学习，有时候我们可能会去质疑镜头下的生活是否真实，是否存在，但是我确实从一些博主的视频中看到了他们对于生活热爱和对自己作品的打磨，也让我看到了更多更优秀的人还在努力的学习，这种正能量对自己的学习也能起到了推动作用。平台消除了物理的距离，让更多优秀的人和作品得到了展示的机会，让人忍不住点赞收藏。</p>
<p>名师指路：从学校毕业了，没了老师该怎么学习？看似失去了继续学习的机会，但相反我们其实有更多的选择，我们可以自己选择老师，加入他们的课程，阅读他们的著作，在专栏下和老师留言互动，答疑解惑。如果你追随的都是同一个作者，那学习专栏和阅读著作有多大的区别呢？当然区别是有的，书籍出版的时候已经就截稿了，已经定型了，读者拿到手上的时侯作者也已经完成交付了，但是专栏是动态的，作者和读者可以在平台上互动，主题和方向是事先确定好的，但是具体的内容会根据读者的反馈调整，比如增加一些章节来回答一些具体的问题，这种方式让读者和作者的距离更近，我们总说读书是和作者交流，但是读书只能是单向的交流，专栏的这种形式，让双向的交流成为可能。另外也会有一些作者会在专栏的基础之上，补充内容章节，出版图书，这其实就是读者和作者共创的产物。目前对我影响比较大的两个老师，一位是<a href="https://coolshell.cn/haoel">左耳朵耗子</a>，给开发人员的职业发展提供了很多指导性的建议和参考，他在<a href="https://time.geekbang.org/">极客时间</a>上的专栏《<a href="https://time.geekbang.org/column/intro/100002201">左耳听风</a>》让我收获良多，如果还不知道这个专栏的朋友，可以订阅学习一下。另一位是<a href="https://baike.baidu.com/item/%E5%90%B4%E5%86%9B/8125425">吴军</a>老师，我在<a href="https://www.dedao.cn/">得到</a>上订阅了他的所有专栏，其中《<a href="https://www.dedao.cn/course/PZNRwQ0qL1MVEbAskxJ3lmz4kgWEnx">硅谷来信</a>》系列干货很多，我也购入了吴军老师的系列书籍，目前看完了《<a href="https://book.douban.com/subject/6709783/">浪潮之巅</a>》、《<a href="https://book.douban.com/subject/27199584/">大学之路</a>》、《<a href="https://book.douban.com/subject/30356082/">具体生活</a>》、《<a href="https://book.douban.com/subject/26838557/">智能时代</a>》、《<a href="https://book.douban.com/subject/30346218/">态度</a>》、《<a href="https://book.douban.com/subject/30144978/">见识</a>》、《<a href="https://book.douban.com/subject/33385217/">全球科技通史</a>》，看书的速度，跟不上老师出书的速度，实属惭愧。</p>
<p>拥抱开源：开源对生活有多少影响，这个还不太好衡量，如果不是做技术的朋友可能不知道，我们平时使用的各种各样的手机应用APP背后都有开源的影子，应用的正常运行离不开后端的服务，提到服务就离不开服务器，现在大多数服务器上都是运行的<a href="https://zh.wikipedia.org/wiki/Linux">Linux</a>操作系统，这是全球享有盛名的开源项目，有上万名顶尖工程师贡献核心代码。在操作系统的基础上运行着各种各样的服务组件，数据库、缓存、中间件、应用容器等等，大多数也是来自开源组件，每个组件背后都有一个活跃的社区贡献代码，开源对于开发人员的好处是我们可以直接查看组件源码，这样就能清楚一些组件模块的实现细节，源码一般都是技术水平较高的一帮工程师写的，看源码的过程也是一个学习的过程，经典的设计思想，好的实现方式和代码风格都可以借鉴到我们自己开发的项目中。</p>
<h4 id="写作探索"><a href="#写作探索" class="headerlink" title="写作探索"></a>写作探索</h4><h5 id="读书有感"><a href="#读书有感" class="headerlink" title="读书有感"></a>读书有感</h5><p>自我教育：阅读是自我教育的一部分，也是生活的一部分，兴趣，好奇心，求知欲是最好的内在动力，看书的时候，可以让我慢下来，静下来，遇到一本好书很愉快和遇到一个非常值得交往的朋友是相似的。</p>
<p>啃大部头：我之前尝试了一下啃《<a href="https://book.douban.com/subject/1477390/">代码大全2</a>》，慢慢啃出了爬山的感觉，刚开始的时候山路不熟悉，一天只能前进10米，一点一点，一步一步，慢慢的走到山顶，一路感慨，风景尽收眼底，第二次尝试的时候，路况已经渐渐熟悉了，速度也快了起来，一天能前进50米，所以当我第二次来到同一个地方的时候，突然就有此感悟，同样的地方，心态不一样，体会也不一样，第一次的时候是哇，走了这么远了快到山顶了，第二次是，哇，我又来到了这个地方，感觉和爬山有点儿像呢，下一次，就是1天前进100米了，等你这个路都熟悉了就可以自己画地图了，通往山顶的路线是怎么样的，或者是站在某个景点，也就是书中的某个知识点，比较迷人有意思，可以标注出来。</p>
<p>讨论交流：读书有意思，更有意思的是，你读了这本书，其他人也读了这本书，你们之间可以彼此交流看法，探讨一些问题，就像上课一样，要是单纯的看课本学习，肯定没有看完课本，然后有老师引导回答你的疑问，或者说你和老师同学在课堂上对一些问题互相探讨交流有意思。这也是为什么好的电视剧出来了，就会有很多人去追，一个是剧本身是真的有意思，另一个就是看完剧之后可以和同事朋友同学一起讨论剧情和细节。</p>
<h5 id="记录分享"><a href="#记录分享" class="headerlink" title="记录分享"></a>记录分享</h5><p>在博客搭建起来之前，我曾经用 <a href="https://dayoneapp.com/">Day One</a> 写过3年的日记，所谓的吾日三醒吾身，就是会反思自己做过的一些事情，记录一些想法和感悟，这是一个对内的过程。后来把过程简化了一下，只是用Note记录一些想法，然后慢慢的开始和朋友讨论一些有意思的问题，分享一些我收获到的感悟和心得，这种方式慢慢的让我感受到了记录和分享的乐趣。记录让我看到了过去自己的一些成长和变化，同时我也意识到，有一个好的习惯作为基础，可以延伸出其他的习惯，只要主要的习惯还在发挥作用，其余的习惯也能跟着保留下来。记录对我自己来说是有价值的，分享能让这份价值传递出去，所以现在我开始尝试通过博客的方式，把好的思路和解决方案记录下来，在不断前进的过程中留下一些脚印，让我能够找到回去的路，也希望能够给后来的人提供一些帮助和指引。</p>
<h5 id="目前理解"><a href="#目前理解" class="headerlink" title="目前理解"></a>目前理解</h5><p>最近一次在外面吃饭的时候，我突然发现写作和炒菜过程差不多，大致分为两个阶段，准备材料和制作成品，制作过程又有各种烹饪手法，讲究色、香、味俱全，给人吸引力和口感，写作过程也是类似的有对应的写作手法和文章结构，写出来的文章读起来怎么样，就和菜的口感差不多，文章内容的价值和食材的营养价值类似，一个作用在精神层面，另一个作用在生理层面。</p>
<p>炒菜和写作还有一个方面很相似，是在选题上，就是你要炒的菜是什么，需要哪些材料，采用那种烹饪方式能做出来，而且味道还不错，写作是先选择一个主题作为核心，围绕这个主题，我需要收集整理那些材料，作为我的素材观点，然后采用那种合适的写作手法和文体结构把一个主题讲清楚。还有一个有意思的点是，炒菜和写作都是技能，只是品尝菜和看别人的文章，是学不会这些技能的，只有自己多尝试多练习，才能越做越好，一开始的话可能会产出黑暗料理和垃圾文章，不过还是不能放弃，只有更多的实践，手艺才会更好，材料就那些，方法步骤也就那些，多炒几遍，多写几次，水平自然会提高。</p>
<p>尝别人炒的菜，读别人写的文章，看不到背后的生产过程和创作过程，只是说能提高我们的品味，但是对提高厨艺和写作能力，没有直接的帮助。如果能直接向作者讨教经验那肯定是不错的，但是这种机会比较难得。只能是我们通过已有的结果，反推和模拟创作过程，划分步骤，补齐原料，然后尝试自己创作，对比自己和原作的区别，当然能够融入自己的个人特色，就更不错了。如果我们能看到创作过程，比如看视频教程，那就可以模仿实践，模仿是学习的最基本方式，你模仿的越接近原作品，那你和作者的水平差距就越小。如果你能尝过一道菜，就能自己把它做出来，而且在味道上不分上下，那你和作者基本就处在同一水平了。</p>
<p>最后一点，反馈很重要，要自己尝自己的菜，自己读自己的文章，同时要让其他人参与进来，反馈问题，求解问题，不断改良优化，这就是刻意练习的实践版了。</p>
<p>补充一点，在我不断完善这篇博客的过程中，我又发现了一点有意思的东西，能够解释为什么把自己的理解写下来可以帮助我们理解和掌握地更好。虽然说我只写了一次，但是我会把自己写的内容看很多次，这就很像我们工作中写的代码，代码只写一次，但是会被自己和其他人阅读很多次，如果出了问题，还需要对问题定位，这个过程就会更细致的检查自己的代码，写完这篇博客的时侯，我也是反复检查了好几次，然后才发布，所以就是这一次又一次的检查审阅，让我对自己写下的内容更熟悉理解更透彻。反思我们日常学习做的笔记，因为不需要公开，只要用到的时候能找到就行，所以大概率是记录1次，回顾0次，过段时间再看又得从头学一遍，以上，养成写博客的习惯还是很重要的。</p>
<h5 id="主题方向"><a href="#主题方向" class="headerlink" title="主题方向"></a>主题方向</h5><p>对于个人博客来说，主题上没有太多的限制，我自己的定位是以技术笔记为主线，记录自己遇到过的问题和解决方案，尝试研究一些新的技术和开发框架的源码，测试一些好用的第三方组件和类库，翻译一些不错的技术文章，回炉学过的计算机的基础知识；以学习生活为支线，整理读书笔记，探索提高学习和阅读效率的方法理论，推荐实用的应用、工具、网站、课程……</p>
<h4 id="生活探索"><a href="#生活探索" class="headerlink" title="生活探索"></a>生活探索</h4><h5 id="平行世界"><a href="#平行世界" class="headerlink" title="平行世界"></a>平行世界</h5><p>平行世界，多元生活，这是在大冰的书里读到的，目前我读过《<a href="https://book.douban.com/subject/25984204/">乖，摸摸头</a>》、《<a href="https://book.douban.com/subject/26575812/">阿弥陀佛么么哒</a>》、《<a href="https://book.douban.com/subject/26844348/">好吗好的</a>》、《<a href="https://book.douban.com/subject/27115882/">我不</a>》、《<a href="https://book.douban.com/subject/27115882/">你坏</a>》、《<a href="https://book.douban.com/subject/33447944/">小孩</a>》，这些作品里面讲述了大冰一些江湖朋友的故事，很多人物的经历都是独一无二的。作者拥有多个职业身份，身份不同所在的地方不同，做的事情不同，接触的人也不同，这就是同一个人，在同一个世界，却有着不同的生活经历，也就是多元的生活。我曾经也问过自己一个问题，如果在满足生存的前提下，只做一件事情，那这件事情是什么？我有过一段时间的思考，后来找到了答案，探索未知世界。人类天生就充满了求知欲和好奇心，只不过随着年龄的增长和知识的丰富，慢慢的累积到了一定程度，在社会上的生存需要的条件已经基本满足，甚至都不需要在学习很多新的东西了，靠经验就能解决大部分的问题，所以有一部分人会失去探索的精神，失去好奇心与求知欲，停止对未知世界的探索，但是新一代的年轻人，却永远不会满足现有的知识和工具，为了好玩儿，为了搞清楚一个问题，他们总会尝试各种方式解决新时代的问题，从而推动新的变革和科技的进步，历史总在重演，科技永远向前。</p>
<h5 id="多元思维"><a href="#多元思维" class="headerlink" title="多元思维"></a>多元思维</h5><p>在《<a href="https://book.douban.com/subject/5346110/">穷查理宝典</a>》中<a href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E7%90%86%C2%B7%E8%8A%92%E6%A0%BC">查理·芒格</a>提出了多元思维模型，社会是复杂的，如果只是靠单一的学科知识，无法完全解释这个世界上的诸多现象，我们在学校接受的教育，各个专业培养出来的学生，都有自己专业独特的思维方式和看待问题的角度，但是这些不同的角度也不能完全把一个事情所有的面都看到，会存在盲点。所谓的多元思维就是说我们应该掌握更多主要学科的基本常识与模型，丰富自身看问题的角度，在生活中遇到事物，尝试联系不同学科的常识与模型，从不同的角度分析问题，这也是目前一些跨学科合作项目能取得重大突破的原因。多元思维还可以和阅人无数结合起来，就是我会关注一些不同国家、不同文化、不同领域、不同背景的博主，他们分享的内容本身就是多元的，通过这种方式我就能更多的了解到自身领域之外的世界。另一个获取多元信息的途径就是得到专栏的评论区，能看到不同领域的人对于同一个问题的探讨和见解，个人从中收获也是蛮多的。</p>
<h5 id="行动准则"><a href="#行动准则" class="headerlink" title="行动准则"></a>行动准则</h5><ol>
<li>发掘自己的核心优势，并把它发挥到极致；</li>
<li>选择一条适合自己的路走下去，做正确的事情，坚持下去；</li>
<li>寻找什么是有效的，坚持去做，发现什么是无效的，坚决避免。</li>
</ol>
<p>最后，从2021开始，让我们一起走向下一个10年，愿我们都能找到自己想要的答案。</p>
]]></content>
      <categories>
        <category>起点</category>
      </categories>
      <tags>
        <tag>探索</tag>
      </tags>
  </entry>
  <entry>
    <title>从上到下打印二叉树 III</title>
    <url>/posts/2021/07410e18dc/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>节点总数 &lt;= 1000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>层序遍历+倒序，题目要求偶数层的元素打印顺序为从右到左，也就是逆序打印，比较容易想到的方式是先按正常从左到右的顺访问元素，把一层的元素都添加到集合后，判断是否为偶数层，如果是就先把集合中的元素反转，然后把集合添加到结果集，如果不是则直接把集合添加到结果集。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 偶数层需要反转集合元素</span></span><br><span class="line">            <span class="keyword">if</span> ((result.size() + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) Collections.reverse(level);</span><br><span class="line">            result.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了99.41%的用户<br>内存消耗：38.5 MB, 在所有 Java 提交中击败了68.74%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>层序遍历+双端队列，整体思路和方法一类似，借助双端队列我们可以通过在每一层选择从队首或队尾添加元素的方式，很自然的得到元素逆序或正序的访问集合，然后把集合添加到结果集即可。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">              	<span class="comment">// 偶数层元素从双端队列队首加入</span></span><br><span class="line">                <span class="keyword">if</span> ((result.size() + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) deque.addFirst(node.val);</span><br><span class="line">              	<span class="comment">// 奇数层元素从双端队列队尾加入</span></span><br><span class="line">                <span class="keyword">else</span> deque.addLast(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(deque);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了99.41%的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了22.91%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂链表的复制</title>
    <url>/posts/2021/0768dc24ea/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<p><strong>示例 1：</strong></p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210320150650.png" style="zoom:67%;" /></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210320150731.png" style="zoom:67%;" /></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210320150814.png" style="zoom:67%;" /></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
<li><code>Node.random</code> 为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>哈希表，遍历链表，为链表中的每个节点生成一个新的节点，把当前节点和新节点的对应关系存入哈希表中，再次遍历，通过当前节点和新节点的对应关系，当前节点和随机节点的的对应关系，我们就可以构造出新节点和新随机节点的对应关系，重复这一过程，直至链表末端，就完成了复杂链表的复制。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(curr.val);</span><br><span class="line">            map.put(curr,node);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span>( curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node node = map.get(curr);</span><br><span class="line">            node.next = map.get(curr.next);</span><br><span class="line">            node.random = map.get(curr.random);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.3 MB, 在所有 Java 提交中击败了26.46%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>从上到下打印二叉树</title>
    <url>/posts/2021/07f54868b/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。<br>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>节点总数 &lt;= 1000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>层序遍历(BFS)，借助队列存放当前层的节点，然后当前层节点依次出队，同时把该节点的非空子节点依次加入到队列中，队列所有元素都出队后，遍历结束。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了99.77%的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了92.86%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的压入、弹出序列</title>
    <url>/posts/2021/06447cc728/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong>  </p>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> 是 <code>popped</code> 的排列。</li>
</ol>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>栈模拟，使用辅助栈模拟出栈和入栈的过程，先按压入顺序把元素入栈，然后比较栈顶元素与弹出序列下标指向元素是否相同，如果是，则栈顶元素出栈，同时弹出序列下标后移，重复这个过程，直到压栈序列中的每个元素都已经入过栈。此时，就可以通过判断辅助栈是否为空，来确定输入的弹出序列是否为压入序列的正确弹出序列。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushed) &#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; popped[i] == stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：2 ms, 在所有 Java 提交中击败了96.35%的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了38.89%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>数组模拟，本质上还是栈模拟的思路，区别是基于数组手动维护入栈和出栈操作，这种方式相对于编程语言提供的原生 <code>Stack</code>，能减少出入栈过程中不必要的操作，从而提升程序运行的效率。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, pop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : pushed) &#123;</span><br><span class="line">            stack[top++] = num;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; stack[top - <span class="number">1</span>] == popped[pop]) &#123;</span><br><span class="line">                top--;</span><br><span class="line">                pop++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38 MB, 在所有 Java 提交中击败了78.36%的用户</p>
          </div>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <url>/posts/2021/06a01a37fb/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>1 &lt;= 数组长度 &lt;= 50000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>哈希表统计，遍历数组统计每个元素出现的次数，然后从哈希表中找出 val 最大的 key 就是所需结果。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> majority = -<span class="number">1</span>, maxcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (val &gt; maxcount) &#123;</span><br><span class="line">                maxcount = val;</span><br><span class="line">                majority = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h5><p>题目要求是找出数组中出现次数超过数组长度一半的数字，我们可以直接在遍历统计过程中判断一个元素出现的次数是否已经超过数组长度的一半，如果是就直接返回当前结果，这样能在一些情况下能够提前返回结果，而不用遍历整个数组，同时也能使代码得到简化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> limit = nums.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; limit) <span class="keyword">return</span> num;</span><br><span class="line">            map.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：13 ms, 在所有 Java 提交中击败了26.95%的用户<br>内存消耗：43.6 MB, 在所有 Java 提交中击败了31.77%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>数组排序，数组中一个元素出现次数如果超过数组长度的一半，那么在数组有序的情况下，数组中间值一定就是这个元素。</p>
<blockquote>
<p>时间复杂度:$O(n\log{}n)$&emsp;空间复杂度:$O(\log{}n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：2 ms, 在所有 Java 提交中击败了60.67%的用户<br>内存消耗：44.5 MB, 在所有 Java 提交中击败了5.00%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210605170502.png" style="zoom:67%;"/></div>

<p><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95">摩尔投票法</a>，核心思想是在一组元素中，如果有元素数量上占优势，也就是超过元素总数的一半，此时所有元素可以被分为两类，我们把数量占优势的元素记为 A，把其他的元素记为 B，对于 A 类元素而言，在所有元素中数量最多，且 A 类中的元素也全部相同，对于 B 类元素而言，在所有元素中数量相对较少，且 B 类中的元素可能相同也可能不同。在这种情况下，我们用一个 A 类元素抵消掉一个 B 类元素，很明显，B 类元素会首先被消耗完，剩下的元素就都是 A 类元素。从算法实现上来说，一开始不知道那个元素是 A 类元素，那个元素是 B 类元素，所以先选定一个候选者 <code>candidate</code> 然后对候选者进行投票，如果当前元素和候选者相同，票数加1，否则票数减1，一个候选者得票为0时，将被下一个候选者替换，最终剩下的候选者就是出现次数最多的元素。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, candidate = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了99.95%的用户<br>内存消耗：41.7 MB, 在所有 Java 提交中击败了68.26%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Bit Manipulation</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/posts/2021/05fd4c32db/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210320152617.png"/></div>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>存储父节点，遍历整棵树，使用哈希表记录所有子节点和父节点的对应关系，对于节点 <code>p</code> ，用 <code>set</code> 集合记录其父节点和所有祖先节点，对于节点 <code>q</code> ，依次向上查找父节点及祖先节点，如果节点在 <code>set</code> 集合中存在，该节点就是 <code>p</code> 、<code>q</code> 节点的最近公共祖先。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;TreeNode,TreeNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        TreeNode pNode = p, qNode = q;</span><br><span class="line">        Set&lt;TreeNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.add(pNode);</span><br><span class="line">            pNode = map.get(pNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(qNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(qNode)) &#123;</span><br><span class="line">                <span class="keyword">return</span> qNode;</span><br><span class="line">            &#125;</span><br><span class="line">            qNode = map.get(qNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(node.left, node);</span><br><span class="line">            dfs(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(node.right, node);</span><br><span class="line">            dfs(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：13 ms, 在所有 Java 提交中击败了8.56%的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了98.55%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>递归求解，对于树中指定的两个节点，它们最近的公共祖先要么是在左子树中，要么是在右子树中，如果左右子树都不包含公共祖先，那么最近的公共祖先就是根节点。节点本身也可以是自己的祖先，所以递归的跳出条件就是根节点为空或者根节点与任意一个指定节点相等，此时返回根节点即可，同时递归过程是自底向上的，可以保证递归找到的两个节点的公共祖先就是最近公共祖先。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> (left == <span class="keyword">null</span>) ? right : ((right == <span class="keyword">null</span>) ? left : root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：7 ms, 在所有 Java 提交中击败了99.98%的用户<br>内存消耗：39.9 MB, 在所有 Java 提交中击败了50.89%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个只出现一次的字符</title>
    <url>/posts/2021/0550f3eaff/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。<br><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= s 的长度 &lt;= 50000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>哈希表记录次数，使用一个数组把字符映射成数组下标，数组元素记录字符出现次数，遍历整个字符串就能得到所有字符出现的次数，然后按照原字符串中的顺序找出第一个出现次数是1的字符，如果找不到就返回空格。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : chs) &#123;</span><br><span class="line">            frequency[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : chs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frequency[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：4 ms, 在所有 Java 提交中击败了99.18%的用户<br>内存消耗：38.8 MB, 在所有 Java 提交中击败了60.73%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>哈希表记录位置，使用哈希表记录每个字符出现的位置，如果哈希表的 key 中不包含该字符就把字符和字符位置记录下来，否则字符出现多次，不满足题目要求，把字符的位置修改为 -1。遍历哈希表，找出其中位置不为 -1 的最小值，就是第一个只出现一次字符的所在位置。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">32</span>);</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(ch)) &#123;</span><br><span class="line">                map.put(ch, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(ch, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (pos != -<span class="number">1</span> &amp;&amp; pos &lt; first) &#123;</span><br><span class="line">                first = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first == length ? <span class="string">&#x27; &#x27;</span> : s.charAt(first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：27 ms, 在所有 Java 提交中击败了54.80%的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了77.72%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>在解法一的基础上，使用队列在字符遍历过程中将首次出现的字符入队，遍历结束后，队列中的字符依次出队，如果字符统计的次数是1，那么这个字符就是第一个只出现一次的字符，返回即可。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] frequency = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            frequency[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (frequency[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (frequency[ch - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：8 ms, 在所有 Java 提交中击败了81.60%的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了83.96%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>从上到下打印二叉树 II</title>
    <url>/posts/2021/05508ccc4/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>节点总数 &lt;= 1000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>广度优先遍历，借助队列，通过广度优先遍历的方式，一次把一层的元素取出来放到同一个集合中，再把集合加入到结果集中，最后就能得到层次遍历的结果。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了94.72%的用户<br>内存消耗：38.7 MB, 在所有 Java 提交中击败了53.76%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>深度优先遍历，在深度优先遍历的方式下，借助变量 <code>depth</code> ，可以访问到储存每一层元素的集合，这样就可以直接把当前访问的元素，加入到对应层级的集合中，注意，结果集大小和访问深度相等的时候，需要先创建一个集合，之后便可以用其储存当前层的元素。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(result, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, TreeNode node, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == depth) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(depth).add(node.val);</span><br><span class="line">        dfs(list, node.left, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(list, node.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.4 MB, 在所有 Java 提交中击败了90.03%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>树的子结构</title>
    <url>/posts/2021/0553dd15fc/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 节点个数 &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>深度优先遍历，按照深度优先的方式遍历树A，对A中的每一个节点借助辅助函数 <code>hasSubStructure</code> 判断从该节点出发是否含有子结构B，如果确实存在则返回<code>true</code> ，利用逻辑或的短路性质在传递结果的同时也能避免不必要的递归。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(m)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = hasSubStructure(A, B);</span><br><span class="line">        result = result || isSubStructure(A.left, B);</span><br><span class="line">        result = result || isSubStructure(A.right, B);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasSubStructure(A.left, B.left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasSubStructure(A.right, B.right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：39.8 MB, 在所有 Java 提交中击败了96.95%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>广度优先遍历，整体思想与解法一相同，但是采用了广度优先遍历的方式，需要借助队列，从理论上来说两种方式的时间空间复杂度是一致的，但是在实际运行中维护队列会带来额外的时间和空间开销，所以解法二实际运行效果不如解法一。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(m)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(A);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.val == B.val &amp;&amp; hasSubStructure(node, B)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSubStructure</span><span class="params">(TreeNode nodeA, TreeNode nodeB)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queueA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queueB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queueA.add(nodeA);</span><br><span class="line">        queueB.add(nodeB);</span><br><span class="line">        <span class="keyword">while</span> (!queueB.isEmpty()) &#123;</span><br><span class="line">            nodeA = queueA.poll();</span><br><span class="line">            nodeB = queueB.poll();</span><br><span class="line">            <span class="keyword">if</span> (nodeA == <span class="keyword">null</span> || nodeA.val != nodeB.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nodeB.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queueA.add(nodeA.left);</span><br><span class="line">                queueB.add(nodeB.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nodeB.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queueA.add(nodeA.right);</span><br><span class="line">                queueB.add(nodeB.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：5 ms, 在所有 Java 提交中击败了5.72%的用户<br>内存消耗：40.8 MB, 在所有 Java 提交中击败了5.12%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中数字出现的次数</title>
    <url>/posts/2021/059d5aa486/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>2 &lt;= nums.length &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>Set去重，遍历数组，把元素添加到Set中，如果添加失败说明元素已存在，需要把该元素剔除掉，Set中剩余的元素就是两个只出现一次的数字。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                set.remove(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">            res[index++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：10 ms, 在所有 Java 提交中击败了15.71%的用户<br>内存消耗：39.7 MB, 在所有 Java 提交中击败了96.45%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a ^ a &#x3D; 0; &#x2F;&#x2F; 相同的两个数异或值为0</span><br><span class="line">a ^ 0 &#x3D; a; &#x2F;&#x2F; 一个数与0异或值为自身</span><br><span class="line">a ^ b ^ c &#x3D; a ^ c ^ b; &#x2F;&#x2F; 异或具有交换律</span><br></pre></td></tr></table></figure>

<p>分组异或，根据异或的性质，先对所有元素进行异或操作，得到的结果就是两个只出现一次数字的异或值<code>res</code>，然后我们取这个值二进制中最低位1所表示的值<code>div</code>，把数组中每个元素与<code>div</code>进行与运算得到的结果作为分组依据。这个最低位1所在的位置是两个只出现一次的数字二进制中最低的不相等的位，通过和这个位的与运算可以把这两个数字区分开，同时对于其他元素来说，如果两个元素是相等的，那么一定会被分到同一个组，最终两个分组中元素异或完的值就都是只出现一次的数字。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            res ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((div &amp; res) == <span class="number">0</span>) &#123;</span><br><span class="line">            div &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; div) == <span class="number">0</span>) &#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：39.9 MB, 在所有 Java 提交中击败了90.13%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>相交链表</title>
    <url>/posts/2021/0521677569/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表：</p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210505124817.png" style="zoom: 67%;" /></div>

<p>在节点 c1 开始相交。</p>
<p><strong>示例 1：</strong></p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210505124838.png" style="zoom:67%;" /></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 </span><br><span class="line">[5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>示例 2：</strong></p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210505124851.png" style="zoom:67%;" /></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 </span><br><span class="line">[3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210505124905.png" style="zoom:67%;" /></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 </span><br><span class="line">skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>如果两个链表没有交点，返回 <code>null</code>.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 $O(n) $时间复杂度，且仅用 $O(1) $内存。</li>
</ul>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>暴力法，从链表 A 出发，把每个节点和链表 B 中的每个节点都比较一下，如果两个节点相等，则两链表相交，且相等的节点就是起始交点。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pB != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pA == pB) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pA;</span><br><span class="line">                &#125;</span><br><span class="line">                pB = pB.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pA = pA.next;</span><br><span class="line">            pB = headB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：789 ms, 在所有 Java 提交中击败了5.01%的用户<br>内存消耗：41 MB, 在所有 Java 提交中击败了91.03%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>哈希表，我们可以先遍历链表 A 中的所有元素，用Set存起来，然后遍历链表 B 中的每一个节点，如果节点在 Set 中，那么这个节点就是两个链表的起始交点。借助哈希表可以降低时间复杂度，但空间复杂度却增加了，这就是典型的空间换时间。</p>
<blockquote>
<p>时间复杂度:$O(m + n)$&emsp;空间复杂度:$O(m)$ 或 $O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode current = headA;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.add(current);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current = headB;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(current)) &#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：8 ms, 在所有 Java 提交中击败了17.73%的用户<br>内存消耗：42.4 MB, 在所有 Java 提交中击败了5.08%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210505124817.png" style="zoom: 67%;" /></div>

<p>双指针，如图我们把 <code>a1-a2</code> 的距离记为 <code>a</code>，把 <code>b1-b3</code> 的距离记为 <code>b</code>，把 <code>c1-c3</code> 的距离记为 <code>c</code>。现在初始化两个指针 <code>pA</code>、<code>pB</code> 分别指向链表 A、B，同时出发向后遍历，当链表 A 遍历到链表尾的时候把指针 <code>pA</code> 指向链表 B，同理当链表 B 遍历到链表尾的时候把指针 <code>pB</code> 指向链表 A。当两个指针相遇时，也就是到节点 c1 的位置，<code>pA</code> 走过的距离为 <code>a + c + b</code> ，<code>pB</code> 走过的距离为 <code>b + c + a</code>，很明显 <code>pA</code> 和 <code>pB</code> 走过的距离是相等的，此时 <code>pA</code> 指向的节点就是链表的起始交点。如果两个链表不相交，<code>pA</code>  和 <code>pB</code> 走过的距离同样相等为 <code>a + b</code>，当两个指针相遇时，分别指向链表 B、A 的表尾。</p>
<blockquote>
<p>时间复杂度:$O(m + n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">if</span> (pA == <span class="keyword">null</span> || pB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = (pA == <span class="keyword">null</span>) ? headB : pA.next;</span><br><span class="line">            pB = (pB == <span class="keyword">null</span>) ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：41.1 MB, 在所有 Java 提交中击败了83.04%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Interview</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/posts/2021/04b66fe035/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。<br><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/valid-anagram/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>排序，拿到一个字符串，先拆分为字符数组，然后对字符排序，之后重新组合成新的字符串，比较两个新字符串的值是否相等即可。</p>
<blockquote>
<p>时间复杂度:$O(n\log{}n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        Arrays.sort(chs);</span><br><span class="line">        s = <span class="keyword">new</span> String(chs);</span><br><span class="line"></span><br><span class="line">        chs = t.toCharArray();</span><br><span class="line">        Arrays.sort(chs);</span><br><span class="line">        t = <span class="keyword">new</span> String(chs);</span><br><span class="line">        <span class="keyword">return</span> s.equals(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：2 ms, 在所有 Java 提交中击败了99.99%的用户<br>内存消耗：38.5 MB, 在所有 Java 提交中击败了86.93%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>哈希表，首先字符范围是只包含小写字母，也就是有26个元素，我们可以使用一个长度为26的数组用来统计每个字符出现的次数，对于字符串 s 来说，拿到一个字符，我们对数组下标对应的值加1，对于字符串 t 来说，拿到一个字符，我们对数组下标对应的值减1。统计完成之后，如果两个字符串是异位词，那么数组中所有元素值都应该是0，如果元素值有不为0的情况，则两个字符串不是异位词。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] chs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            chs[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            chs[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count : chs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：5 ms, 在所有 Java 提交中击败了44.43%的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了69.49%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>Sort</tag>
        <tag>Hash Table</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串中第m个出现n次的字符</title>
    <url>/posts/2021/04f07ec942/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串 str ，编写一个函数用来查找字符串中第 m 个出现 n 次的字符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：str&#x3D;“abbcdedbf” m &#x3D; 1 n &#x3D; 3</span><br><span class="line">输出：b</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>  </p>
<p>你可以假设字符串只包含小写字母。</p>
<span id="more"></span>

<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>哈希表，我们使用一个保持元素加入顺序的 <code>LinkedHashMap</code> 来统计每一个字符出现的次数，统计出词频之后遍历哈希表中元素，如果元素出现次数和要查找字符出现次数 n 相等，m 减 1，当 m 值为 0 时所对应的元素就是目标字符，如果遍历完哈希表都没有找到目标字符，则目标字符不存在。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Character <span class="title">search</span><span class="params">(String str, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; dict = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : str.toCharArray()) &#123;</span><br><span class="line">            dict.put(ch, dict.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : dict.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict.get(ch) == n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>输入：str=“abbcdedbf” m = 2 n = 1<br>输出：c</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>String</tag>
        <tag>Hash Table</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中最大连续1的个数</title>
    <url>/posts/2021/046f7808b6/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：一个二维数组，每一个元素为0或者1</span><br><span class="line">输出：最多有多少个1是连续的</span><br><span class="line">连续的定义：上下左右相邻</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[1, 0, 0, 1, 0],</span><br><span class="line"> [1, 0, 1],</span><br><span class="line"> [0, 0, 1, 0, 1],</span><br><span class="line"> [1, 0, 1, 0, 1],</span><br><span class="line"> [1, 0, 1, 1]]</span><br><span class="line">输出：5 </span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[1, 0, 0, 1, 0],</span><br><span class="line"> [1, 0, &#39;1&#39;],</span><br><span class="line"> [0, 0, &#39;1&#39;, 0, 1],</span><br><span class="line"> [1, 0, &#39;1&#39;, 0, 1],</span><br><span class="line"> [1, 0, &#39;1&#39;, &#39;1&#39;]]</span><br><span class="line">&#39;1&#39;的总数就是该数组中最大连续1的个数</span><br></pre></td></tr></table></figure>
<p>实现方法：<code>Integer maxArea(List&lt;List&lt;Integer&gt;&gt; data)</code></p>
<span id="more"></span>

<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>深度优先遍历，为了不修改原始数据，我们定义一个二维数组用来存储原始集合中的数值，由于原始集合中子集合的长度不统一，需要按子集合中的最大长度来初始化数组。之后把原始集合中对应的值为1的元素赋值给自定义数组，同时把元素对应的下标加入搜索起始集合中。遍历搜索起始集合，从每一个起始点出发，往上下左右四个方向搜索，如果超过边界或者搜索得到的值为0，就返回，否则继续往下搜索，统计1的个数，同时将已访问的数组元素值修改为0。把每个起始点出发得到的连续1的个数都和最大值比较，最终能得到全局的最大值，也就是最大连续1的个数。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(mn)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">maxArea</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = data.size(), n = data.get(<span class="number">0</span>).size(), max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : data) &#123;</span><br><span class="line">            n = Math.max(n, list.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; starts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.get(i).size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.get(i).get(j) != <span class="number">0</span>) &#123;</span><br><span class="line">                    arr[i][j] = <span class="number">1</span>;</span><br><span class="line">                    starts.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] start : starts) &#123;</span><br><span class="line">            max = Math.max(max, search(arr, start[<span class="number">0</span>], start[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">search</span><span class="params">(<span class="keyword">int</span>[][] arr, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= arr.length || col &lt; <span class="number">0</span> || col &gt;= arr[<span class="number">0</span>].length || arr[row][col] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        arr[row][col] = <span class="number">0</span>;</span><br><span class="line">        count += search(arr, row - <span class="number">1</span>, col);</span><br><span class="line">        count += search(arr, row, col + <span class="number">1</span>);</span><br><span class="line">        count += search(arr, row + <span class="number">1</span>, col);</span><br><span class="line">        count += search(arr, row, col - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; test = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        test.add(Arrays.asList(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        test.add(Arrays.asList(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        test.add(Arrays.asList(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        test.add(Arrays.asList(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        test.add(Arrays.asList(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(maxArea(test));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>输出结果：5</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Medium</tag>
        <tag>Depth-first Search</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>队列的最大值</title>
    <url>/posts/2021/045bee9125/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是$O(1)$。<br>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1。<br><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>使用数组记录插入队列的值，遍历队列所有元素求最大值，这种处理方式能够得到正确结果，但是不能完全满足题目要求。</p>
<blockquote>
<p>时间复杂度:$O(1)$(插入、删除)，$O(n)$(求最大值)&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i != tail; i++) &#123;</span><br><span class="line">            max = Math.max(queue[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        queue[tail++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[head++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：38 ms, 在所有 Java 提交中击败了96.06%的用户<br>内存消耗：43.6 MB, 在所有 Java 提交中击败了98.47%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>定义队列<code>queue</code>进行元素的插入和删除，定义双端队列<code>order</code>用于维护队列中的最大值。对于插入操作，需要比较插入值和<code>order</code>队尾值的大小，如果队尾值较小就把队尾元素删除，重复这一过程，直至队尾元素为空或者插入值比队尾元素小，此时就可以把插入值同时插入队列<code>queue</code>和<code>order</code>。对于删除操作，需要比较两个队列队首元素是否相同，如果相同就把两个队列的队首元素都删除，如果不相同只删除<code>queue</code>队首元素。对于求最大值操作每次返回<code>order</code>队首元素值即可。对于<code>order</code>中的每个元素来说，入队和出队都只有1次，所以可以保证整体插入操作的均摊时间复杂度为$O(1)$。</p>
<blockquote>
<p>时间复杂度:$O(1)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; queue;</span><br><span class="line">    LinkedList&lt;Integer&gt; order;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        order = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order.isEmpty() ? -<span class="number">1</span> : order.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!order.isEmpty() &amp;&amp; order.peekLast() &lt; value) &#123;</span><br><span class="line">            order.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(value);</span><br><span class="line">        order.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> front = queue.pop();</span><br><span class="line">        <span class="keyword">if</span> (front == order.peek()) &#123;</span><br><span class="line">            order.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：38 ms, 在所有 Java 提交中击败了96.06%的用户<br>内存消耗：46.4 MB, 在所有 Java 提交中击败了36.11%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Stack</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>连续子数组的最大和</title>
    <url>/posts/2021/0440b2b7b/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组，求所有子数组的和的最大值。<br>要求时间复杂度为$O(n)$。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设nums数组长度为n，下标从0～n-1</span><br><span class="line">用f(i)表示以下标i结尾的子数组最大和</span><br><span class="line">f(i)的状态转移方程如下：</span><br><span class="line">f(i) &#x3D; max&#123;f(i-1) + nums[i], nums[i]&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划，根据状态转移方程，我们用一个新数组依次记录每一个下标元素作为结尾的子数组和的最大值，然后将这个值与全局的最大值比较，全局最大值的最终结果就是所有子数组和的最大值。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            maxSum = Math.max(dp[i], maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了94.77%的用户<br>内存消耗：38.4 MB, 在所有 Java 提交中击败了66.93%的用户</p>
          </div>

<p>借助滚动数组思想，定义一个变量<code>curSum</code>用来记录<code>f(i-1)</code>的值，这样可以不使用额外的数组，空间复杂度降到了$O(1)$。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>, maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            curSum = Math.max(curSum + num, num);</span><br><span class="line">            maxSum = Math.max(curSum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了94.77%的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了86.58%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Divide and Conquer</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>求1+2+…+n</title>
    <url>/posts/2021/04d18b4167/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>1 &lt;= n &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>不考虑题目限制的话，我们可以借助求和公式直接计算出结果。</p>
<blockquote>
<p>时间复杂度:$O(1)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：35.2 MB, 在所有 Java 提交中击败了91.68%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A:False B:True</span><br><span class="line">A &amp;&amp; B &#x3D; False &#x2F;&#x2F; 短路</span><br><span class="line"></span><br><span class="line">A:True B:False</span><br><span class="line">A &amp;&amp; B &#x3D; False &#x2F;&#x2F; 非短路</span><br></pre></td></tr></table></figure>

<p>考虑题目给出的限制条件，我们可以通过递归的方式累加求和，但是需要考虑递归终止条件，由于限制使用<code>if</code>和条件判断语句<code>（A?B:C）</code>，只能采取其他方式。定义A、B两个表达式，进行逻辑运算<code>A &amp;&amp; B</code>，如果A表达式不满足条件，B表达式就不会被执行，这就是逻辑运算的短路性质，利用这个性质我们把B表达式作为递归入口，当A表达式不成立的时候，递归终止。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> stop = (n &gt; <span class="number">1</span>) &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：35.6 MB, 在所有 Java 提交中击败了65.01%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树根节点到叶子节点的所有路径和</title>
    <url>/posts/2021/0447e1359/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个仅包含数字 0 − 9 的二叉树，每一条从根节点到叶子节点的路径都可以用一个数字表示。<br>例如根节点到叶子节点的一条路径是 1 → 2 → 3 ,那么这条路径就用 123 来代替。<br>计算根节点到叶子节点的所有路径表示的数字之和。<br><strong>示例 1:</strong></p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210408101148.png"/></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：25</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13</span><br><span class="line">因此，数字总和 &#x3D; 12 + 13 &#x3D; 25</span><br></pre></td></tr></table></figure>

<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210408115709.jpg" style="zoom:67%;"/></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,9,0,5,1]</span><br><span class="line">输出：1026</span><br><span class="line">解释：</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40</span><br><span class="line">因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>树的深度不超过 <code>10</code></li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>深度优先遍历，每次计算当前节点所代表的值，到达叶子节点，也就是一个节点的左、右节点都为空，返回节点值，累加每层左、右路径之和即可得到最终结果。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left,sum);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right,sum);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：35.7 MB, 在所有 Java 提交中击败了90.88%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>广度优先遍历，使用两个队列分别记录节点和值，只有节点是叶子节点的时侯才累加到总和中，其他情况仅记录节点当前路径所表示的值，队列中节点为空的时侯，就能得到所有路径和。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; numQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        numQueue.add(root.val);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = nodeQueue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = numQueue.poll();</span><br><span class="line">                TreeNode node = nodeQueue.poll();</span><br><span class="line">                TreeNode left = node.left, right = node.right;</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += num;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        nodeQueue.add(left);</span><br><span class="line">                        numQueue.add(num * <span class="number">10</span> + left.val);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        nodeQueue.add(right);</span><br><span class="line">                        numQueue.add(num * <span class="number">10</span> + right.val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了26.33%的用户<br>内存消耗：36 MB, 在所有 Java 提交中击败了56.73%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Medium</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/posts/2021/0333147ff9/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。<br><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>整数转二进制，使用<code>Integer</code>的<code>toBinaryString()</code>方法可以直接得到整数的二进制字符串，然后统计字符串中1出现的次数即可。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String str = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：2 ms, 在所有 Java 提交中击败了96.88%的用户<br>内存消耗：35.6 MB, 在所有 Java 提交中击败了19.39%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &amp; (n - 1) &#x2F;&#x2F; 消除二进制中最右边的1</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 0 1 0 &#x2F;&#x2F; 10</span><br><span class="line">&amp; 1 0 0 1 &#x2F;&#x2F; 9</span><br><span class="line">---------</span><br><span class="line">  1 0 0 0 &#x2F;&#x2F; 10 &amp; 9 消除了10二进制中最右边的1</span><br><span class="line">-----------------------------------------</span><br><span class="line">  1 0 0 0 &#x2F;&#x2F; 8</span><br><span class="line">&amp; 0 1 1 1 &#x2F;&#x2F; 7</span><br><span class="line">---------</span><br><span class="line">  0 0 0 0 &#x2F;&#x2F; 8 &amp; 7 消除了8二进制中最右边的1</span><br></pre></td></tr></table></figure>

<p>位运算，通过上述示例可以看出，一个数能进行多少次 <code>n&amp;(n-1)</code>操作，其对应的二进制数就包含多少个1，且运算最终结果为0。</p>
<blockquote>
<p>时间复杂度:$O(k)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了96.88%的用户<br>内存消耗：35.3 MB, 在所有 Java 提交中击败了70.23%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的第k大节点</title>
    <url>/posts/2021/03a9424924/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵二叉搜索树，请找出其中第k大的节点。<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br>1 ≤ k ≤ 二叉搜索树元素个数</p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>中序遍历，二叉搜索树的一大特性就是其中序遍历得到的结果是一个升序排列的序列，第k大的节点就是序列的倒数第k个位置对应的值。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inOrder(root, list);</span><br><span class="line">        <span class="keyword">return</span> list.get(list.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inOrder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了41.36%的用户<br>内存消耗：38.4 MB, 在所有 Java 提交中击败了35.10%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>正常的中序遍历对树节点的访问顺序是左-根-右，这样访问得到的序列是按升序排列的，目标是要找到第k大的节点，如果我们按照右-根-左的节点顺序访问，能够得到降序的序列，这样访问的第k个节点就是第k大的节点，就不用访问所有节点了，时间空间效率也能得到提升。</p>
<blockquote>
<p>时间复杂度:$O(k)$&emsp;空间复杂度:$O(k)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = kthLargest(root.right, k);</span><br><span class="line">        <span class="keyword">if</span> (++cnt == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = kthLargest(root.left, k);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：37.7 MB, 在所有 Java 提交中击败了99.92%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合</title>
    <url>/posts/2021/03a433fb66/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<div style="display: inline-block;"><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210408150904.png" style="zoom:67%;"/></div>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：digits &#x3D; &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围<code> [&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>递归+回溯，先构建数字和字母的对应关系，从字符串首个数字出发，获取数字对应的英文字母串，从字母串首个字母开始，拼接字符，递归处理字符串下一个数字，处理完之后，回溯，删除当前拼接的字符，当字符串索引值与其长度相等的时候，拼接得到的新字符串就是符合要求的一种情况，把它添加到结果列表中，跳出递归，整个递归结束就能得到所有字母组合的结果。</p>
<blockquote>
<p>时间复杂度:$O(3^m \times 4^n)$&emsp;空间复杂度:$O(m + n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String nums = <span class="string">&quot;23456789&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Character, String&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] words = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.isEmpty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length(); i++) &#123;</span><br><span class="line">            dict.put(nums.charAt(i), words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String digits, <span class="keyword">int</span> index, StringBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            res.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String word = dict.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            builder.append(word.charAt(i));</span><br><span class="line">            dfs(digits, index + <span class="number">1</span>, builder);</span><br><span class="line">            builder.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了83.34%的用户<br>内存消耗：37 MB, 在所有 Java 提交中击败了81.79%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Backtracking</tag>
        <tag>String</tag>
        <tag>Recursion</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个排序的链表</title>
    <url>/posts/2021/03faa1cd64/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 链表长度 &lt;= 1000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>迭代，初始化一个伪头节点<code>prev</code>，和当前节点<code>curr</code>，每次比较两个链表当前值的大小，将<code>curr</code>节点的下一个节点指向两个链表中值较小的节点，再把当前节点和较小值节点向后移动一位。当其中一个链表到达表尾的时侯，如果另一个链表还有剩余节点，则直接把当前节点的下一个节点指向剩余的节点的第一个节点。</p>
<blockquote>
<p>时间复杂度:$O(m + n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), curr = prev;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了99.66%的用户<br>内存消耗：38 MB, 在所有 Java 提交中击败了99.86%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>递归，有一个链表节点是空节点就返回另一个链表节点，比较两个链表的节点值，把值较小节点的下一个节点指向下一层递归返回的节点，然后返回值较小的节点，递归结束就能得到合并之后的链表。</p>
<blockquote>
<p>时间复杂度:$O(m + n)$&emsp;空间复杂度:$O(m + n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了99.66%的用户<br>内存消耗：38.6 MB, 在所有 Java 提交中击败了48.44%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>在排序数组中查找数字 I</title>
    <url>/posts/2021/03af7fb63c/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>统计一个数字在排序数组中出现的次数。<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 数组长度 &lt;= 50000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>顺序查找，遍历数组统计<code>target</code>出现的次数。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) count++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target) <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：41.2 MB, 在所有 Java 提交中击败了77.38%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>二分查找，使用二分先找到<code>target</code>所在的位置，然后往两边扩散，这样能充分利用数组的有序性，也能避免查找目标有多个情况下，查找遗漏的问题。</p>
<blockquote>
<p>时间复杂度:$O(\log{}n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                    <span class="keyword">int</span> l = mid - <span class="number">1</span>, r = mid + <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; nums[l--] == target) c++;</span><br><span class="line">                    <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; nums[r++] == target) c++;</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：41.1 MB, 在所有 Java 提交中击败了94.23%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的深度</title>
    <url>/posts/2021/03fc8ea05/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。<br>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p><strong>提示：</strong><br><code>节点总数 &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>广度优先遍历，使用队列把二叉树每层的节点都存起来，每访问完一层节点深度加<code>1</code>，队列为空时，就能得到最大深度。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了21.76%的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了85.87%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>深度优先遍历，如果根节点为空返回<code>0</code>，否则返回左右子树最大深度再加上<code>1</code>，也就是每一次递归深度加<code>1</code>。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.4 MB, 在所有 Java 提交中击败了59.12%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的镜像</title>
    <url>/posts/2021/035bf14681/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。<br>例如输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>镜像输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 节点个数 &lt;= 1000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>直接递归，递归过程中交换左右子树的位置，当根节点为空时，递归返回。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = mirrorTree(root.left);</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：35.7 MB, 在所有 Java 提交中击败了86.90%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>使用队列，队列初始化后加入根节点，当队列不为空时，取出一个节点，交换左右子树的位置，把非空的左右子树加入到队列中，队列中无剩余节点，返回根节点即可。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：35.8 MB, 在所有 Java 提交中击败了52.60%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的节点</title>
    <url>/posts/2021/0382b88d87/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p><img src="https://cdn.jsdelivr.net/gh/yisimg/storage/img/20210326120945.png"></p>
<p>链表节点的删除，具体来说就是把要删除节点的前一个节点指向删除节点的下一个节点，如果要删除的节点是头节点，直接返回头节点的下一个节点即可。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr.val != val) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = curr.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：37.8 MB, 在所有 Java 提交中击败了73.58%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>0～n-1中缺失的数字</title>
    <url>/posts/2021/0328c29680/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>1 &lt;= 数组长度 &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>直接遍历，如果数组元素值与其对应的下标值不一致，缺失的数字就是下标值，否则缺失的就是数字中的最大值。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.9 MB, 在所有 Java 提交中击败了64.01%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a ^ a &#x3D; 0; &#x2F;&#x2F; 相同的两个数异或值为0</span><br><span class="line">a ^ 0 &#x3D; a; &#x2F;&#x2F; 一个数与0异或值为自身</span><br><span class="line">a ^ b ^ c &#x3D; a ^ c ^ b; &#x2F;&#x2F; 异或具有交换律</span><br></pre></td></tr></table></figure>
<p>位运算，根据异或的性质，我们很容易使用异或运算找出两组数中缺失的元素。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> miss = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            miss ^= i;</span><br><span class="line">            miss ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> miss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.8 MB, 在所有 Java 提交中击败了80.73%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>二分查找，定义左端点<code>left</code>，右端点<code>right</code>，中间点<code>mid</code>，如果中间点与其对应的数组元素值相等，说明中间点左侧没有缺失的数字，此时将左端点移动到中间点右侧1位，否则中间点左侧存在缺失的数字，将右端点移动到中间点左侧1位，左端点超过右端点所在位置，查找结束，左端点指向的位置就是缺失的数字。</p>
<blockquote>
<p>时间复杂度:$O(\log{}n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：39 MB, 在所有 Java 提交中击败了29.96%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人的运动范围</title>
    <url>/posts/2021/036f7abd/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m,n &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<span id="more"></span>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>深度优先遍历，机器人从坐标<code>[0, 0]</code>开始移动，搜索的时候只需要向下和向右移动就能走完所有符合条件的格子。机器人能到达的格子数，从整体上来看就是当前所在的格子计为1，加上右边相邻格子能到达的格子总数，加上下边相邻格子能到达的格子总数，依次递归就能得到最终的结果。为了避免重复计算，对于已经走过的格子需要修改访问状态，遇到超出方格范围、已经访问过、限制访问的格子递归返回。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(mn)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(m, n, k, <span class="number">0</span>, <span class="number">0</span>, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visit[i][j] || forbid(i, j, k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(m, n, k, i + <span class="number">1</span>, j, visit) + dfs(m, n, k, i, j + <span class="number">1</span>, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">forbid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            sum += j % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt; k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了85.13%的用户<br>内存消耗：35.3 MB, 在所有 Java 提交中击败了80.07%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>广度优先遍历，借助队列可以通过迭代的方式访问格子，整体思路与解法一类似，但是访问格子的顺序不太一样，同时队列元素的插入与删除会带来额外的时间开销。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(mn)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[][] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] pos = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> r = pos[<span class="number">0</span>], c = pos[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || visit[r][c] || forbid(r, c, k)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visit[r][c] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">forbid</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            sum += j % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">            j /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt; k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：6 ms, 在所有 Java 提交中击败了17.10%的用户<br>内存消耗：37.1 MB, 在所有 Java 提交中击败了13.59%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <url>/posts/2021/03796ae9fd/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ol>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>使用双指针，定义左端点<code>left</code>，右端点<code>right</code>，从数组两端向中间移动，当左端点遇到的值为奇数时，左端点右移，直到值为偶数，同理，当右端点遇到的值为偶数时，右端点左移，直到值为奇数，此时交换左右端点对应的值，左右端点相遇，交换过程结束，数组元素的顺序就是符合要求的结果。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] % <span class="number">2</span> != <span class="number">0</span>) left++;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] % <span class="number">2</span> == <span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            nums[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：2 ms, 在所有 Java 提交中击败了97.89%的用户<br>内存消耗：46.3 MB, 在所有 Java 提交中击败了70.40%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/posts/2021/03952c518/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code><span id="more"></span></li>
</ul>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[1 1 1 1 1 1],</span><br><span class="line"> [1 2 2 2 2 1],</span><br><span class="line"> [1 2 3 3 2 1],</span><br><span class="line"> [1 2 2 2 2 1],</span><br><span class="line"> [1 1 1 1 1 1]]</span><br></pre></td></tr></table></figure>
<p>矩阵从外向里打印，也就是先打印最外层的1，再打印中间层的2，最后打印最里层的3，顺时针打印，就是按上、右、下、左的顺序依次遍历矩阵每一层的值。清楚了打印规则，我们就可以模拟这个过程依次把遍历过程中取到的元素存入结果数组中。每一层遍历结束的时侯，就把上、下、左、右的外边界都向里移动一位，当上下边界重合，左右边界也重合的时侯遍历结束，返回结果数组即可。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[rows * cols];</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, down = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (up &lt;= down &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = left; u &lt;= right; u++) &#123;</span><br><span class="line">                res[index++] = matrix[up][u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = up + <span class="number">1</span>; r &lt;= down; r++) &#123;</span><br><span class="line">                res[index++] = matrix[r][right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (up &lt; down &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = right - <span class="number">1</span>; d &gt; left; d--) &#123;</span><br><span class="line">                    res[index++] = matrix[down][d];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = down; l &gt; up; l--) &#123;</span><br><span class="line">                    res[index++] = matrix[l][left];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">            left++;</span><br><span class="line">            down--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了97.59%的用户<br>内存消耗：39.9 MB, 在所有 Java 提交中击败了24.71%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈实现队列</title>
    <url>/posts/2021/03f88f910f/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>队列的特征是先进先出，栈的特征是先进后出，要想用栈模拟队列，需要使用双栈。定义两个栈<code>head</code>和<code>tail</code>，插入元素的时侯直接存入<code>tail</code>栈，删除元素的时侯，先判断<code>head</code>栈是否为空，如果不为空，就直接弹出顶部元素，如果为空，就把<code>tail</code>栈中的元素依次弹出并存入<code>head</code>栈中，再弹出<code>head</code>栈顶部元素。</p>
<blockquote>
<p>时间复杂度:$O(1)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        tail = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        tail.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tail.isEmpty()) &#123;</span><br><span class="line">                head.push(tail.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.isEmpty() ? -<span class="number">1</span> : head.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：57 ms, 在所有 Java 提交中击败了73.86%的用户<br>内存消耗：46.1 MB, 在所有 Java 提交中击败了97.88%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组的最小数字</title>
    <url>/posts/2021/036e519af2/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>顺序查找，通过观察可以发现数组旋转之后，最小元素所在的位置刚好是元素数值递减的第一个位置，所以我们只需要遍历数组找到第一个递减的元素返回即可，如果数组遍历完都没有找到递减的元素，就返回数组的首元素。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] &gt; numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了90.30%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>二分查找，定义左端点<code>left</code>，右端点<code>right</code>，以及中间点<code>mid</code>，比较中间点和右端点对应数组元素值的大小，我们的目标是要找到最小值。当右端点对应的值更大时，最小值的范围是在中间点的左侧，所以把右端点移动到中间点位置，当中间点对应的值更大时，最小值的范围是在中间点的右侧，所以把左端点移动到中间点的下一个位置，当中间点和右端点对应的值相等时，即数组中的元素重复，此时把右端点左移一位。左右端点相遇的时侯，左端点对应的值就是旋转数组的最小数字。</p>
<blockquote>
<p>时间复杂度:$O(\log{}n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.3 MB, 在所有 Java 提交中击败了46.47%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列</title>
    <url>/posts/2021/03cc713db/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong><br><code>0 &lt;= n &lt;= 100</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>由递推公式，我们很容易写出求解数列第<code>n</code>项的递归形式，当<code>n</code>比较小的时侯可以直接得到结果，但是递归求解的时间复杂度是指数级别的，随着<code>n</code>的增大，计算所需耗费的时间也是呈指数增长，当<code>n</code>比较大的时侯，不推荐使用递归求解。</p>
<blockquote>
<p>时间复杂度:$O(2^n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> (fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger">
            <p>超出时间限制，最后执行的输入：43</p>
          </div>


<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>从斐波那契数列的定义出发，我们可以使用迭代法求解数列的第<code>n</code>项。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            c %= <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：35.1 MB, 在所有 Java 提交中击败了88.73%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>最小的k个数</title>
    <url>/posts/2021/0347d70a1/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>按照题目要求，最直观的处理方式就是先排序，然后取排序后数组的前k个元素组成新数组返回即可。</p>
<blockquote>
<p>时间复杂度:$O(n\log{}n)$&emsp;空间复杂度:$O(\log{}n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：7 ms, 在所有 Java 提交中击败了72.51%的用户<br>内存消耗：39.7 MB, 在所有 Java 提交中击败了68.57%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>题目要求找出最小的k个元素，我们可以使用一个大根堆实时维护数组中前k小的元素，初始化堆的时候，先直接把数组前k个元素加入堆中，从第k+1个元素开始，把元素值与堆顶值做比较，如果比堆顶值小，就把堆顶元素弹出，把数组元素加入到堆中。数组遍历结束的时候，用堆中的元素组成的新数据就是所需结果。</p>
<blockquote>
<p>时间复杂度:$O(n\log{}k)$&emsp;空间复杂度:$O(\log{}k)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(((o1, o2) -&gt; o2 - o1));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            queue.offer(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.peek() &gt; arr[i]) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：20 ms, 在所有 Java 提交中击败了33.19%的用户<br>内存消耗：39.5 MB, 在所有 Java 提交中击败了88.20%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>使用分治递归把大问题划分为子问题求解，借鉴快速排序的划分函数，我们可以选取一个中间值<code>target</code>把数组划分为两部分，同时调整两部分的值，使得左边部分的元素值都小于<code>target</code>，右边部分的元素值都大于<code>target</code>。递归的过程中，我们只需要处理包含前k个小元素的部分，当我们处理到的元素下标是第k个元素时，划分结束，原数组的前k个元素就是整个数组中的前k个小元素。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(\log{}n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(arr, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, target = arr[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span> (arr[i] &lt; target);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span> (arr[j] &gt; target);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> == k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">            process(arr, l, j, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            process(arr, j + <span class="number">1</span>, r, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：39.7 MB, 在所有 Java 提交中击败了74.27%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Divide and Conquer</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/posts/2021/0382b7a1a9/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 节点个数 &lt;= 5000</code></p>
<span id="more"></span>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>迭代法，把当前节点记为<code>curr</code>，<code>prev</code>表示前一个节点，<code>next</code>表示下一个节点，我们可以在遍历链表的同时把当前节点<code>curr</code>的下一个节点指向前一个节点<code>prev</code>，从而完成链表的反转。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.2 MB, 在所有 Java 提交中击败了52.24%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>链表反转刚好符合先进后出的情况，我们可以借助栈，通过递归的方式完成链表的反转。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了70.06%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/posts/2021/03eb78a2fc/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>1 &lt;= k &lt; s.length &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>比较直观的处理方式就是通过截取子串，然后重新拼接组合成目标字符串。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：38.1 MB, 在所有 Java 提交中击败了88.91%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>借助一个与字符串长度相等的字符数组，从位置n处切分字符串，先把字符串后半段字符依次存入字符数组，再把字符串前半段字符依次存入字符数组，使用额外空间直接赋值的方式，避免了对原字符串对应字符数组元素的大量迁移，从而降低时间损耗。解法二与解法一处理方式从原理上来说是一致的，解法一使用的是字符串内置函数处理，底层使用了<code>System.arraycopy</code>，性能上比我们自己对字符数组赋值表现更好。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            chs[index++] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            chs[index++] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行结果执行用时：3 ms, 在所有 Java 提交中击败了35.46%的用户<br>内存消耗：37.9 MB, 在所有 Java 提交中击败了95.97%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/posts/2021/03cd96fb91/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= s 的长度 &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>使用String内置<code>replaceAll()</code>方法，只需一行代码就能完成题目要求，但实际测试时间性能表现一般。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：3 ms, 在所有 Java 提交中击败了15.63%的用户<br>内存消耗：36.3 MB, 在所有 Java 提交中击败了46.79%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>使用String内置<code>toCharArray()</code>方法，我们可以得到一个字符数组，遍历这个数组，如果元素是空格就把需要替换的字符串添加到<code>StringBuilder</code>中，否则直接添加当前字符。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：36.1 MB, 在所有 Java 提交中击败了90.12%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>除了上述两种处理方式，我们也可以通过初始化字符数组来构造字符串，需要注意的是，如果遇到空格，需要同时往字符数组中添加替换串拆解之后的3个字符。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[len * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                chs[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                chs[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                chs[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chs[size++] = ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chs, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：36.2 MB, 在所有 Java 提交中击败了77.09%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/posts/2021/032aa4f70/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个 <code>m * n</code> 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong><br>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target = <code>5</code>，返回 <code>true</code>。<br>给定 target = <code>20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong><br><code>0 &lt;= m &lt;= 1000</code><br><code>0 &lt;= n &lt;= 1000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>暴力查找，即遍历数组中的每一个元素，如果元素的值与<code>target</code>相等，则返回<code>true</code>，否则返回<code>false</code>。</p>
<blockquote>
<p>时间复杂度:$O(mn)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：44 MB, 在所有 Java 提交中击败了85.50%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>线性查找，在解法一中，暴力查找明显没有充分利用数据的特征，数组元素本身在一定程度上是有序的，我们利用这种有序性可以有效降低查找的次数。不难发现以数组右上角的值作为起始值与<code>target</code>进行比较，如果值比<code>target</code>大，继续往下查找，如果值比<code>target</code>小，继续往左查找，如果超过了数组的边界，或者查找的位置到达了左下角也没能找到<code>target</code>则返回<code>false</code>，如果找到了则返回<code>true</code>。查找过程中，往左最多查找<code>n</code>次，往下最多查找<code>m</code>次，总的查找次数不超过<code>m + n</code>次。</p>
<blockquote>
<p>时间复杂度:$O(m + n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[x][y] &lt; target) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：43.9 MB, 在所有 Java 提交中击败了92.41%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Medium</tag>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>从尾到头打印链表</title>
    <url>/posts/2021/03b724efa/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>从尾到头打印链表刚好符合先进后出的情况，自然我们会想到使用栈这种数据结构，先遍历链表节点入栈，然后按元素出栈顺序构建新的数组就能得到想要的结果。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.addFirst(curr.val);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = stack.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了72.23%的用户<br>内存消耗：39 MB, 在所有 Java 提交中击败了64.50%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>还有一种解法也是比较容易想到的，就是先获取链表的长度，然后创建一个同等大小的数组，链表从前往后遍历，数组从后往前填充元素，少了入栈和出栈的时间开销，这种处理方式时间性能会更好一些。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;res.length;i++) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            res[count] = curr.val;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：39 MB, 在所有 Java 提交中击败了66.36%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>除了使用栈，我们还可以尝试用递归的方式处理，本质上递归是调用系统的堆栈，和栈原理是一致的，不过还需要借助辅助的函数和变量。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recursive(head, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursive</span><span class="params">(ListNode head, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            idx = count - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recursive(head.next, count + <span class="number">1</span>);</span><br><span class="line">        res[idx - count] = head.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了72.23%的用户<br>内存消耗：39.8 MB, 在所有 Java 提交中击败了12.01%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中倒数第k个节点</title>
    <url>/posts/2021/031c9c196c/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。  </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.  </span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><p>这个题目的思路是比较清晰的，使用快慢指针，开始的时侯让快指针<code>p1</code>先走<code>k</code>步，然后慢指针<code>p2</code>和快指针同时向后移动，当快指针<code>p1</code>运动到链表尾部的时侯，返回慢指针<code>p2</code>指向的节点即可。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = head, p2 = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：36.2 MB, 在所有 Java 提交中击败了79.12%的用户</p>
          </div>

<p>需要注意的地方是题目给的测试用例没有包含超出链表长度范围的用例，对于这种情况可以在快指针<code>p1</code>移动过程中进行判断，如果快指针移动的过程中已经到达了链表末尾，则直接返回空，这部分代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = head, p2 = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 增加非空判断</span></span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Two Pointers</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的连续正数序列</title>
    <url>/posts/2021/03ba44daea/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。  </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>1 &lt;= target &lt;= 10^5</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>比较容易想到的解法就是枚举+暴力，就是从第一个元素开始累加，如果累加和与<code>target</code>相等则把和清零，换到下一个元素作为起始值累计，由于累加的元素至少要有2个，而且和不会超过<code>target</code>，所以只需要枚举到中间位置<code>target/2+1</code>即可。</p>
<blockquote>
<p>时间复杂度:$O(n\sqrt{n})$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, mid = target / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= mid; j++) &#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[j - i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                        arr[k - i] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.add(arr);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>执行用时：8 ms, 在所有 Java 提交中击败了13.15%的用户<br>内存消耗：36.5 MB, 在所有 Java 提交中击败了78.21%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>因为是求连续的元素和，可以借助求和公式简化运算，使用双指针根据条件判断向右移动，在解法一的基础之上，更加充分的利用已知信息来优化时间效率，当区间<code>[left,right]</code>累加和为<code>target</code>的时侯，必然有<code>[left+1,right]</code>累加和小于<code>target</code>，这种情况下就可以直接把<code>right</code>后移一位，从而避免重复计算。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>; left &lt; right; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (right + left) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    arr[i] = left + i;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：4 ms, 在所有 Java 提交中击败了58.34%的用户<br>内存消耗：36.4 MB, 在所有 Java 提交中击败了90.87%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>借助滑动窗口的思想，当累加和小于<code>target</code>的时侯，右窗口扩大1位，当累加和大于<code>target</code>的时侯，左窗口缩小1位，窗口滑动的最大距离为<code>target/2+1</code>，求和的过程只用到了简单运算，相较于解法二，解法三在时间效率上得到了更进一步的提升。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>, sum = <span class="number">3</span>, limit = (target &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; limit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                sum += right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                        arr[i] = left + i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.add(arr);</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>执行用时：2 ms, 在所有 Java 提交中击败了97.59%的用户<br>内存消耗：36.8 MB, 在所有 Java 提交中击败了15.95%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/posts/2021/038f265477/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong><br><code>2 &lt;= n &lt;= 100000</code></p>
<span id="more"></span>

<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">Leetcode</a></p>
<h4 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h4><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>用一个大小相等的数组<code>array</code>记录下标为<code>num</code>的元素重复次数，如果重复次数大于1，则该元素为重复元素，就是需要返回的结果。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[num] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[num]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>执行用时：1 ms, 在所有 Java 提交中击败了83.55%的用户<br>内存消耗：46 MB, 在所有 Java 提交中击败了84.31%的用户</p>
          </div>

<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>与解法一类似，把数组换成Hash表，添加元素的时候判断Hash表中是否已经存在该元素，如果存在，就把当前元素返回。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(n)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>执行用时：5 ms, 在所有 Java 提交中击败了47.78%的用户<br>内存消耗：48.3 MB, 在所有 Java 提交中击败了15.04%的用户</p>
          </div>

<h5 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h5><p>解法一和解法二的空间复杂度都为$O(n)$，不能继续优化，我们可以换一种处理方式，同样是遍历数组，由于数组中元素范围是在<code>0～n-1</code>，没有重复元素的时候，每个元素在数组中的位置都是唯一的，通过把数组元素的值交换到值所对应的数组下标位置，我们只需要一个临时变量<code>temp</code>就能完成交换过程，如果要交换的两个元素值相等，那么存在重复元素，把当前元素返回。</p>
<blockquote>
<p>时间复杂度:$O(n)$&emsp;空间复杂度:$O(1)$</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[temp];</span><br><span class="line">                nums[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success">
            <p>执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户<br>内存消耗：46.1 MB, 在所有 Java 提交中击败了72.16%的用户</p>
          </div>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LCOF</tag>
        <tag>Easy</tag>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
</search>
